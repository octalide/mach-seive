use          std.runtime;
use          std.types.size;
use          std.types.string;
use          std.types.bool;
use          std.text.parse;
use          std.types.list;
use          std.types.result;
use          std.types.option;
use console: std.io.console;
use mem:     std.system.memory;
use time:    std.system.time;

fun sieve(lower: u64, upper: u64, primes: []bool) Option[str] {
    if (upper <= lower) {
        ret some[str]("upper bound must be greater than lower bound");
    }

    val size: u64 = upper - lower;

    if (primes.len < size) {
        ret some[str]("provided buffer size is smaller than required");
    }

    if (primes.data == nil) {
        ret some[str]("provided buffer has null data pointer");
    }

    # mark non-primes
    var i: u64 = lower;
    for (i < upper) {
        if (i <= 2) {
            i = i + 1;
            cnt;
        }

        if (i % 2 == 0) {
            # even numbers (except 2) are not prime
            primes[i - lower] = false;
            i = i + 1;
            cnt;
        }

        # if this number is already marked as not prime, skip it
        if (primes[i - lower] == false) {
            i = i + 1;
            cnt;
        }

        # remove multiples of the current number
        var j: u64 = i * i;
        for (j < upper) {
            primes[j - lower] = false;
            j = j + i;
        }

        i = i + 1;
    }

    ret none[str]();
}

$main.symbol = "main";
fun main(args: []str) i64 {
    var limit: u64 = 100000000;
    console.print("usage: %s [limit] (default: %u)\n", args[0], limit);

    if (args.len > 1) {
        limit = parse_u64_dec(args[1]);
    }

    console.print("finding primes up to %u\n", limit);

    val opt_len: usize = limit :: usize;
    if ((opt_len :: u64) != limit) {
        console.print("error: limit is too large for this platform\n");
        ret 1;
    }

    var opt_allocate: Option[*bool] = mem.allocate[bool](opt_len);
    if (opt_allocate.is_none()) {
        console.print("error: memory allocation failed\n");
        ret 1;
    }

    var primes: []bool;
    primes.data = opt_allocate.unwrap();
    primes.len  = limit;

    mem.fill[bool](primes.data, true, limit :: usize);

    val start:     time.Duration = time.now();
    val opt_sieve: Option[str]   = sieve(0, limit, primes);
    val elapsed:   time.Duration = time.since(start);

    if (opt_sieve.is_some()) {
        console.print("error: %s\n", opt_sieve.unwrap());
        ret 1;
    }

    # collect indices of primes (the prime numbers themselves)
    var res_list_new: Result[List[u64], str] = list_new[u64](limit / 10);
    if (res_list_new.is_err()) {
        console.print("error: %s\n", res_list_new.unwrap_err());
        ret 1;
    }

    val indices: List[u64] = res_list_new.unwrap_ok();

    var i: u64 = 0;
    for (i < primes.len) {
        # skip 0 and 1
        if (i <= 1) { 
            i = i + 1;
            cnt;
        }

        if (primes[i] == true) {
            val err: Option[str] = indices.push(i);
            if (err.is_some()) {
                console.print("error: %s\n", err.unwrap());
                ret 1;
            }
        }
        
        i = i + 1;
    }

    console.print("found:       %u\n", indices.len);
    console.print("time taken:  %u ms\n", elapsed.milliseconds());

    if (indices.len > 0) {
        val opt_first: Option[u64] = indices.get(0);
        if (opt_first.is_none()) {
            console.print("error retrieving first prime\n");
            ret 1;
        }

        val opt_last: Option[u64] = indices.get(indices.len - 1);
        if (opt_last.is_none()) {
            console.print("error retrieving last prime\n");
            ret 1;
        }

        console.print("first prime: %u\n", opt_first.unwrap());
        console.print("last prime:  %u\n", opt_last.unwrap());
    }

    ret 0;
}
