use          std.runtime;
use          std.types.string;
use          std.types.bool;
use          std.text.parse;
use          std.types.list;
use          std.types.result;
use          std.types.option;
use console: std.io.console;
use mem:     std.system.memory;
use time:    std.system.time;

fun seive(lower: u64, upper: u64) Result[[]bool, str] {
    val size:   u64 = upper - lower;
    var primes: []bool;
    primes.len  = size;

    val res_alloc: Option[*bool] = mem.allocate[bool](size);
    if (res_alloc.is_none()) {
        ret err[[]bool, str]("failed to allocate memory for primes array");
    }

    primes.data = res_alloc.unwrap();

    # initialize all entries as true
    var i: u64 = 0;
    for (i < size) {
        primes[i] = true;
        i = i + 1;
    }

    # mark non-primes
    i = lower;
    for (i < upper) {
        if (i <= 2) {
            i = i + 1;
            cnt;
        }

        if (i % 2 == 0) {
            # even numbers (except 2) are not prime
            primes[i - lower] = false;
            i = i + 1;
            cnt;
        }

        # if this number is already marked as not prime, skip it
        if (primes[i - lower] == false) {
            i = i + 1;
            cnt;
        }

        # remove multiples of the current number
        var j: u64 = i * i;
        for (j < upper) {
            primes[j - lower] = false;
            j = j + i;
        }

        i = i + 1;
    }

    ret ok[[]bool, str](primes);
}

$main.symbol = "main";
fun main(args: []str) i64 {
    var limit: u64 = 100000000;
    console.print("usage: %s [limit] (default: %u)\n", args[0], limit);

    if (args.len > 1) {
        limit = parse_u64_dec(args[1]);
    }

    console.print("finding primes up to %u\n", limit);

    val start:     u64                    = time.now();
    val res_seive: Result[[]bool, str] = seive(0, limit);
    val end:       u64                    = time.now();

    if (res_seive.is_err()) {
        console.print("error: %s\n", res_seive.unwrap_err());
        ret 1;
    }

    val primes: []bool = res_seive.unwrap_ok();

    # collect indices of primes (the prime numbers themselves)
    var res_list_new: Result[List[u64], str] = list_new[u64](limit / 10);
    if (res_list_new.is_err()) {
        console.print("error: %s\n", res_list_new.unwrap_err());
        ret 1;
    }

    val indices: List[u64] = res_list_new.unwrap_ok();

    var i: u64 = 0;
    for (i < primes.len) {
        # skip 0 and 1
        if (i <= 1) { 
            i = i + 1;
            cnt;
        }

        if (primes[i] == true) {
            val err: Option[str] = indices.push(i);
            if (err.is_some()) {
                console.print("error: %s\n", err.unwrap());
                ret 1;
            }
        }
        
        i = i + 1;
    }

    console.print("found:       %u\n", indices.len);
    console.print("time taken:  %u ns\n", end - start);

    if (indices.len > 0) {
        val opt_first: Option[u64] = indices.get(0);
        if (opt_first.is_none()) {
            console.print("error retrieving first prime\n");
            ret 1;
        }

        val opt_last: Option[u64] = indices.get(indices.len - 1);
        if (opt_last.is_none()) {
            console.print("error retrieving last prime\n");
            ret 1;
        }

        console.print("first prime: %u\n", opt_first.unwrap());
        console.print("last prime:  %u\n", opt_last.unwrap());
    }

    ret 0;
}
