use          std.runtime;
use          std.types.string;
use          std.types.bool;
use          std.text.parse;
use          std.types.list;
use console: std.io.console;
use mem:     std.system.memory;
use time:    std.system.time;

fun seive(lower: u64, upper: u64) []bool {
    val size: u64 = upper - lower;
    val primes: []bool = mem.alloc<bool>(size);

    # initialize all entries as true
    var i: u64 = 0;
    for (i < size) {
        primes[i] = true;
        i = i + 1;
    }

    # mark non-primes
    i = lower;
    for (i < upper) {
        if (i < 2) {
            cnt;
        }

        if (i % 2 == 0) {
            primes[i] = false;
            cnt;
        }

        # remove multiples of the current number
        var j: u64 = i * i;
        for (j < upper) {
            primes[j] = false;
            j = j + i;
        }
    }

    ret primes;
}

#@symbol("main")
fun main(args: []string) i64 {
    var limit: u64 = 100000000;

    if (args.len > 1) {
        limit = parse_u64_dec(args[1]);
    }

    console.print("finding primes up to %d\n", limit);

    val start:  u64    = time.now();
    val primes: []bool = seive(0, limit);
    val end:    u64    = time.now();

    # collect indices of primes (the prime numbers themselves)
    var indices: List<u64> = with_capacity<u64>(1);
    var i: u64 = 0;
    for (i < primes.len) {
        # skip 0 and 1
        if (i <= 1) { cnt; }

        if (primes[i] == true) {
            indices.push(i);
        }
    }

    console.print("found %d primes\n", indices.len);
    console.print("time taken: %d ns\n", end - start);

    if (indices.len > 0) {
        console.print("first prime: %d\n", indices[0]);
        console.print("last prime:  %d\n", indices[indices.len - 1]);
    }

    ret 0;
}
